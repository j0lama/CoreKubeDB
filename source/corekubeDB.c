#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "log.h"
#include "user.h"
#include "crypto.h"

#define OK 0
#define ERROR 1

/* Create two hashmaps with the following structure:
* HashMap1: <IMSI><UserInfo>
* HashMap2: <TMSI><UserInfo>
*/

const uint8_t ascii_map[] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //  !"#$%&'
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ()*+,-./
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // 01234567
	0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 89:;<=>?
	0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // @ABCDEFG
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // HIJKLMNO
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PQRSTUVW
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XYZ[\]^_
	0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // `abcdefg
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // hijklmno
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pqrstuvw
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xyz{|}~.
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ........
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // ........
};

void key_to_hex(uint8_t * key_hex, char * key_str)
{
	uint8_t  pos, err = 0;
	uint8_t  idx0;
	uint8_t  idx1;

	if(key_str[0] == '0' && key_str[1] == 'x')
		err += 2;

	for (pos = 0; ((pos < 32) && (pos < strlen(key_str))); pos += 2) {
		idx0 = (uint8_t)key_str[pos+err+0];
		idx1 = (uint8_t)key_str[pos+err+1];
		key_hex[(pos)/2] = (uint8_t)(ascii_map[idx0] << 4) | ascii_map[idx1];
	}

	return;
}

enum colums{IMSI_COL, KEY_COL, OP_OPC_COL, OPC_COL};

void process_line(char * line, ssize_t line_len)
{
	char * token;
	int column = 0, opc_flag;
	const char delim[2] = ",";
	UserInfo * new_user;
	uint8_t op_key[16];

	/* Check comment line or empty line */
	if(line[0] == '#' || line_len <= 1)
		return;

	/* Allocate memory for a new user */
	new_user = new_user_info();
	if(new_user == NULL) {
		printError("Unable to allocate memory for a new user.\n");
		return;
	}

	/* Get the first token */
	token = strtok(line, delim);

	/* Iterate over the tokens/columns */
	while( token != NULL ) {
		switch(column) {
			case IMSI_COL:
				set_user_imsi(new_user, token);
				break;
			case KEY_COL:
				key_to_hex(get_user_key(new_user), token);
				break;
			case OP_OPC_COL:
				if(!strcmp(token, "opc"))
					opc_flag = 0;
				else if(!strcmp(token, "op"))
					opc_flag = 1;
				else {
					printError("Invalid operator's code type.\n");
					free_user_info(new_user);
					return;
				}
				break;
			case OPC_COL:
				/* Convert the OP to OPC if necessary */
				if(opc_flag == 1) {
					key_to_hex(op_key, token);
					generate_opc(get_user_key(new_user), op_key, get_user_opc(new_user));
				}
				else
					key_to_hex(get_user_opc(new_user), token);
				break;
			default:
				break;
		}
		column++; /* Increase column index */
		token = strtok(NULL, delim); /* Get next token */
	}

#ifdef DEBUG
	show_user_info(new_user);
#endif

	/* Add UserInfo structure to both hashmap structures */

	return;
}

int read_db_file(const char * db_file)
{
	FILE * file;
	char * line = NULL;
	size_t len = 0;
	ssize_t read;

	file = fopen(db_file, "r");
	if(file == NULL) {
		printError("Unable to open file at: %s\n", db_file);
		return ERROR;
	}

	while ((read = getline(&line, &len, file)) != -1) {
		process_line(line, read);
	}

	return OK;
}

int init_db(const char * db_file)
{
	/* Initialize hashmap structures */
	/* TODO */

	/* Read DB from file */
	if(read_db_file(db_file) == ERROR) {
		printError("Error reading DB file.\n");
		return ERROR;
	}

	return OK;
}

int main(int argc, char const *argv[])
{
	printInfo("Starting CoreKubeDB...\n");
	init_db(argv[1]);
	return 0;
}